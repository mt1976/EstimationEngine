package jobs

import (
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/gocarina/gocsv"
	core "github.com/mt1976/ebEstimates/core"
	"github.com/mt1976/ebEstimates/dao"
	dm "github.com/mt1976/ebEstimates/datamodel"
	"github.com/mt1976/ebEstimates/logs"
)

func Data_Job_impl(j dm.JobDefinition) dm.JobDefinition {
	j.Name = "ConfigImportExport"
	j.Period = ""
	j.Description = "Import/Export Data Config from CSV"
	j.Type = core.Adhoc
	j.ID = j.Name
	return j
}

func Data_Run_impl() (string, error) {

	message := ""
	jobName := Data_Job().Name
	inPath := ""
	outPath := ""
	ssMode := ""
	noWorkItems := 0
	action := ""

	//Get Mode from Data Settings and branch
	ssMode, err := dao.Data_Get(jobName, JOB_MODE, dm.Data_Category_State)
	if err != nil {
		return "No Mode Specified for " + jobName, err
	}

	//Get Action from Data
	action, err = dao.Data_Get(jobName, JOB_ACTION, dm.Data_Category_State)
	if err != nil {
		return "No Action Specified for " + jobName, err
	}

	//Get inPath from Data
	inPath, err = dao.Data_Get(jobName, JOB_IN_PATH, dm.Data_Category_Path)
	if err != nil {
		return "No Input Path Specified for " + jobName, err
	}

	//Get outPath from Data
	outPath, err = dao.Data_Get(jobName, JOB_OUT_PATH, dm.Data_Category_Path)
	if err != nil {
		return "No Output Path Specified for " + jobName, err
	}

	actionUpper := strings.ToUpper(action)
	switch actionUpper {
	case JOB_ACTION_EXPORT:

		var shouldReturn bool
		var exportMessage string
		var exportError error
		noWorkItems, message, shouldReturn, exportMessage, exportError = processDataExport(outPath, jobName, err, ssMode)
		if shouldReturn {
			return exportMessage, exportError
		}
	case JOB_ACTION_IMPORT:
		//Get Data from Spreadsheet and Update Data
		if inPath == "" {
			return "No Input Path Specified for " + jobName, err
		}

		//Get Data from Spreadsheet and Update Data
		var importMessage string
		var importError error
		noWorkItems, message, importMessage, importError = processDataImport(inPath, jobName, err, ssMode)
		if importMessage != "" {
			return importMessage, importError
		}

	default:
		return "Invalid Mode Specified for " + jobName + " " + core.DQuote(ssMode), err
	}

	ret := RecordJobStatusInfo(message, noWorkItems, action, jobName, inPath, outPath, ssMode)
	if ret != "" {
		message = "Unable to Update Data for " + jobName + " " + ret
	}
	return message, nil
}

func processDataExport(outPath string, jobName string, err error, ssMode string) (int, string, bool, string, error) {
	var export []DataItemIO

	now := time.Now().Format("20060102_150405")

	fileName := "/" + now + ".csv"
	resultsFile := "/" + now + ".nfo"

	if outPath == "" {
		return 0, "", true, "No Output Path Specified for " + jobName, err
	}

	noitems, items, err := dao.Data_GetMigrateable()
	noWorkItems := noitems
	if err != nil || noWorkItems == 0 {
		return 0, "", true, "Unable to Get Data for " + jobName, err
	}

	for _, item := range items {
		exportItem := DataItemIO{}
		exportItem.DataID = item.DataID
		exportItem.Category = item.Category
		exportItem.Class = item.Class
		exportItem.Field = item.Field
		exportItem.Value = item.Value
		if item.Value != "" {
			export = append(export, exportItem)
		}
	}

	exportFile, err := os.Create(outPath + fileName)
	if err != nil {
		panic(err)
	}
	results, err := os.Create(outPath + resultsFile)
	if err != nil {
		panic(err)
	}
	//csvContent, err := gocsv.MarshalString(&export)
	//if err != nil {
	//	panic(err)
	//}
	err = gocsv.MarshalFile(&export, exportFile)
	if err != nil {
		panic(err)
	}
	//fmt.Println(csvContent)
	results.WriteString(fmt.Sprintf("Application: %s\n", core.ApplicationName()))
	results.WriteString(fmt.Sprintf("Version: %s\n", core.ReleaseIdentityVerbose()))
	results.WriteString(fmt.Sprintf("No of Items: %d \n", noWorkItems))
	results.WriteString(fmt.Sprintf("File: %s \n", fileName))
	results.WriteString(fmt.Sprintf("Generated On: %s\n", core.ApplicationHostname()))
	results.WriteString(fmt.Sprintf("Generated By: %s\n", core.GetHostIP()))
	results.WriteString(fmt.Sprintf("Generated At: %s\n", now))
	results.WriteString(fmt.Sprintf("Generated From: %s\n", core.ApplicationName()))
	results.WriteString(fmt.Sprintf("Generated Company: %s\n", core.ApplicationCompanyName()))
	results.WriteString(fmt.Sprintf("Generated Job: %s\n", Data_Job().Name))
	results.WriteString(fmt.Sprintf("Generated DB Server: %s\n", core.ApplicationSQLServer()))
	results.WriteString(fmt.Sprintf("Generated DB Database: %s\n", core.ApplicationSQLDatabase()))
	results.WriteString(fmt.Sprintf("Generated DB Level: %s\n", core.DB_Version()))

	fmt.Printf("export: %v\n", export)
	message := "Data Exported to " + outPath + fileName
	trialMode := TrialMode(ssMode)
	if !trialMode {
		logs.Storing("Exporting Data to ", outPath+fileName)

	} else {
		message = "Trial Mode - No Data Written"
		logs.Storing("Exporting Data to ", outPath+fileName+" (Trial Mode - No Data Written)")

	}
	exportFile.Close()
	results.Close()
	return noWorkItems, message, false, "", nil
}

func processDataImport(inPath string, jobName string, err error, ssMode string) (int, string, string, error) {

	// Open CSV file
	csvFile, err := os.Open(inPath)
	if err != nil {
		return 0, "cannot open source file", "", err
	}
	defer csvFile.Close()

	processData := []*DataItemIO{}

	if err := gocsv.UnmarshalFile(csvFile, &processData); err != nil {
		panic(err)
	}
	for _, item := range processData {
		//fmt.Println("Hello, ", item.DataID)
		if !TrialMode(ssMode) {
			var data dm.Data
			data.DataID = item.DataID
			data.Category = item.Category
			data.Class = item.Class
			data.Field = item.Field
			data.Value = item.Value

			_, err := dao.Data_StoreProcess(data, Data_Job().Name)
			if err != nil {
				return 0, "Unable to Store Data", "", err
			}

		} else {
			logs.Storing("Importing Data from ", inPath+" (Trial Mode - No Data Written)")
			fmt.Printf("item: %v\n", item)
		}
	}

	return 0, "", "", nil
}
